---
title: 线程安全
---
# 多线程
## 竞态条件&临界区
在同一程序中运行多个线程本身不会导致问题，问题在于多个线程访问了相同的资源。如，同一内存区（变
量，数组，或对象）、系统（数据库，web services 等）或文件。实际上，这些问题只有在一或多个线程向这些
资源做了写操作时才有可能发生，只要资源没有发生变化,多个线程读取相同的资源就是安全的。

- 竞态条件: 当两个线程竞争同一个资源时，如果对访问顺序敏感，则称为竞态条件。
- 临界区:导致竞态条件发生的代码区称作临界区。

> 在临界区中使用适当的同步就可以避免竞态条件

## 锁
### 公平锁&非公平锁
公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。

非公平锁指在每次尝试获取锁时无视等待队列，直接尝试获取锁

>Semaphore信号量类似锁的机制，分公平信号量和非公平信号量。

## JUC(java.util.concurrent)
### CountDownLatch:
用来控制一个线程等待多个线程，内部维护一个计数器每次调用 countDown() 方法会让计数器的值减 1，减到 0 的时候，那些因为调用 await() 方法而在等待的线程就会被唤醒。
#### CountDownLatch的使用场景:
- 确保某个计算在其需要的所有资源都被初始化之后才继续执行。
- 确保某个服务在其依赖的所有其他服务都已启动后才启动。
- 等待知道某个操作的所有者都就绪在继续执行。

### CycliBarriar:
用来控制多个线程互相等待，只有当多个线程都到达时，这些线程才会继续执行。和 CountdownLatch 相似，都是通过维护计数器来实现的。线程执行 await() 方法之后计数器会减 1，并进行等待，直到计数器为 0，所有调用 awati() 方法而在等待的线程才能继续执行。

> CyclicBarrier 和 CountdownLatch 的一个区别是，CyclicBarrier 的计数器通过调用 reset() 方法可以循环使用，所以它才叫做循环屏障。

### Semaphore:
Semaphore 类似于操作系统中的信号量，可以控制对互斥资源的访问线程数。其内部维护了一组虚拟许可，通过构造器指定许可的数量，每次线程执行操作时先通过acquire方法获得许可，执行完毕再通过release方法释放许可。如果无可用许可，那么acquire方法将一直阻塞，直到其它线程释放许可。

### 线程安全的类
1 无状态的对象一定是线程安全的:无状态指的是它不包含任何域，也不包含任何对其他类中域的引用。计算过程中的临时状态是保存在线程栈的局部变量中，并且只能由当前执行的线程访问。
